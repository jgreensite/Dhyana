<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Autechre-like Continuous Music Generator</title>
  <!-- Tone.js (Open-Source) -->
  <script 
    src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.26/Tone.min.js" 
    integrity="sha512-E1+I25m31WNRmyAH22KKKpwm2pyuVsZaffz4gquzAs3Ehu2/ryULMco0nPlzqcHLPywj7FK3ZtOdBJf/9Y5bhQ=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer">
  </script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 0;
      padding: 2em;
      background: #111;
      color: #eee;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    button {
      font-size: 1.2em;
      padding: 0.8em 1.2em;
      cursor: pointer;
      background: #333;
      color: #eee;
      border: 2px solid #666;
      border-radius: 4px;
      margin-bottom: 1em;
    }
    button:hover {
      background: #444;
    }
    #log {
      width: 100%;
      max-width: 600px;
      margin: 1em auto 0;
      background: #000;
      color: #0f0;
      font-family: monospace;
      font-size: 0.9em;
      padding: 1em;
      text-align: left;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #333;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>Autechre-like Continuous Music Generator</h1>
  <p>Tap “Start” to unlock audio and begin. Watch the log for drum hits, synth notes, etc.</p>
  <button id="toggleBtn">Start</button>
  <div id="log"></div>

  <script>
    // ----------------------------
    // 1. Logging Helper
    // ----------------------------
    function logMessage(message) {
      const logDiv = document.getElementById("log");
      const p = document.createElement("p");
      p.textContent = message;
      logDiv.appendChild(p);
      // Auto-scroll to bottom
      logDiv.scrollTop = logDiv.scrollHeight;
      // (Optional) If you want to limit the log size:
      // if (logDiv.childNodes.length > 100) {
      //   logDiv.removeChild(logDiv.firstChild);
      // }
    }

    // ----------------------------
    // 2. Global Audio Setup
    // ----------------------------
    const drumSamples = {
      kick: "https://raw.githubusercontent.com/danigb/samples/master/drums/TR-808/kick.wav",
      snare: "https://raw.githubusercontent.com/danigb/samples/master/drums/TR-808/snare.wav",
      hatClosed: "https://raw.githubusercontent.com/danigb/samples/master/drums/TR-808/hh.wav",
      hatOpen: "https://raw.githubusercontent.com/danigb/samples/master/drums/TR-808/ohh.wav"
    };

    // Players for drum samples
    const kickPlayer = new Tone.Player(drumSamples.kick).toDestination();
    const snarePlayer = new Tone.Player(drumSamples.snare).toDestination();
    const hatClosedPlayer = new Tone.Player(drumSamples.hatClosed).toDestination();
    const hatOpenPlayer = new Tone.Player(drumSamples.hatOpen).toDestination();

    // A simple synth for melodic lines
    const synth = new Tone.Synth({
      oscillator: {
        type: "fatsawtooth",
        count: 3,
        spread: 20
      },
      envelope: {
        attack: 0.01,
        decay: 0.2,
        sustain: 0.3,
        release: 0.5
      }
    });

    // Effects chain
    const filter = new Tone.AutoFilter({
      frequency: "4n",
      baseFrequency: 200,
      octaves: 2.6,
      filter: {
        type: "bandpass"
      }
    }).start();

    const reverb = new Tone.Reverb({
      decay: 2,
      wet: 0.3
    }).toDestination();

    synth.connect(filter);
    filter.connect(reverb);

    // Global BPM
    Tone.Transport.bpm.value = 120;

    // We'll use 16 steps per measure
    const stepsPerMeasure = 16;
    let currentStep = 0;

    // Patterns for each measure (refreshed each measure)
    let drumPattern = {
      kick: [],
      snare: [],
      hatClosed: [],
      hatOpen: []
    };
    let synthPattern = [];

    // Pentatonic scale for melodic notes
    const scale = ["A3", "C4", "D4", "E4", "G4", "A4", "C5", "D5", "E5"];

    // -------------
    // 3. Randomization
    // -------------
    function randomizeDrumPattern() {
      drumPattern.kick = Array.from({ length: stepsPerMeasure }, () => (Math.random() < 0.4 ? 1 : 0));
      drumPattern.snare = Array.from({ length: stepsPerMeasure }, () => (Math.random() < 0.25 ? 1 : 0));
      drumPattern.hatClosed = Array.from({ length: stepsPerMeasure }, () => (Math.random() < 0.5 ? 1 : 0));
      drumPattern.hatOpen = Array.from({ length: stepsPerMeasure }, () => (Math.random() < 0.1 ? 1 : 0));
    }

    function randomizeSynthPattern() {
      synthPattern = Array.from({ length: stepsPerMeasure }, () => {
        // 30% chance to play a note
        if (Math.random() < 0.3) {
          const note = scale[Math.floor(Math.random() * scale.length)];
          return note;
        }
        return null;
      });
    }

    function randomizeEffects() {
      reverb.wet.value = Math.random() * 0.5;       // 0 - 0.5
      reverb.decay = Math.random() * 3 + 0.5;       // 0.5 - 3.5
      filter.baseFrequency = Math.random() * 1000 + 200; // 200 - 1200
    }

    // Initialize patterns/effects
    randomizeDrumPattern();
    randomizeSynthPattern();
    randomizeEffects();

    // ---------------------------
    // 4. Scheduling Loop
    // ---------------------------
    const loop = new Tone.Loop((time) => {
      // Drum triggers
      if (drumPattern.kick[currentStep]) {
        kickPlayer.start(time);
        logMessage(`Kick at step ${currentStep}`);
      }
      if (drumPattern.snare[currentStep]) {
        snarePlayer.start(time);
        logMessage(`Snare at step ${currentStep}`);
      }
      if (drumPattern.hatClosed[currentStep]) {
        hatClosedPlayer.start(time);
        logMessage(`Closed hat at step ${currentStep}`);
      }
      if (drumPattern.hatOpen[currentStep]) {
        hatOpenPlayer.start(time);
        logMessage(`Open hat at step ${currentStep}`);
      }

      // Synth trigger
      const note = synthPattern[currentStep];
      if (note) {
        synth.triggerAttackRelease(note, "16n", time);
        logMessage(`Synth note ${note} at step ${currentStep}`);
      }

      currentStep = (currentStep + 1) % stepsPerMeasure;

      // If we just wrapped a measure, randomize new patterns & effects
      if (currentStep === 0) {
        logMessage("---- New measure randomization ----");
        randomizeDrumPattern();
        randomizeSynthPattern();
        randomizeEffects();
      }
    }, "16n").start(0);

    // -------------
    // 5. Start/Stop UI
    // -------------
    let isPlaying = false;
    const toggleBtn = document.getElementById("toggleBtn");

    toggleBtn.addEventListener("click", async () => {
      if (!isPlaying) {
        // *** Important for mobile: Unlock audio context ***
        await Tone.start();
        logMessage("Audio context unlocked");

        Tone.Transport.start();
        toggleBtn.textContent = "Stop";
        logMessage("Transport started");
      } else {
        Tone.Transport.stop();
        toggleBtn.textContent = "Start";
        logMessage("Transport stopped");
      }
      isPlaying = !isPlaying;
    });
  </script>
</body>
</html>