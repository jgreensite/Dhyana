<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Autechre-like Continuous Music Generator</title>
  <!-- Tone.js (Open-Source) -->
  <script 
    src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.26/Tone.min.js" 
    integrity="sha512-E1+I25m31WNRmyAH22KKKpwm2pyuVsZaffz4gquzAs3Ehu2/ryULMco0nPlzqcHLPywj7FK3ZtOdBJf/9Y5bhQ==" 
    crossorigin="anonymous"
    referrerpolicy="no-referrer">
  </script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin: 0;
      padding: 2em;
      background: #111;
      color: #eee;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    button {
      font-size: 1.2em;
      padding: 0.8em 1.2em;
      cursor: pointer;
      background: #333;
      color: #eee;
      border: 2px solid #666;
      border-radius: 4px;
    }
    button:hover {
      background: #444;
    }
  </style>
</head>
<body>
  <h1>Autechre-like Continuous Music Generator</h1>
  <p>Click "Start/Stop" to toggle the music. Wait a few measures to hear how the beat & tones morph.</p>
  <button id="toggleBtn">Start</button>

  <script>
    // ----------------------------
    // Global Audio / Tone.js Setup
    // ----------------------------
    const drumSamples = {
      kick: "https://raw.githubusercontent.com/danigb/samples/master/drums/TR-808/kick.wav",
      snare: "https://raw.githubusercontent.com/danigb/samples/master/drums/TR-808/snare.wav",
      hatClosed: "https://raw.githubusercontent.com/danigb/samples/master/drums/TR-808/hh.wav",
      hatOpen: "https://raw.githubusercontent.com/danigb/samples/master/drums/TR-808/ohh.wav"
    };

    // Players for drum samples
    const kickPlayer = new Tone.Player(drumSamples.kick).toDestination();
    const snarePlayer = new Tone.Player(drumSamples.snare).toDestination();
    const hatClosedPlayer = new Tone.Player(drumSamples.hatClosed).toDestination();
    const hatOpenPlayer = new Tone.Player(drumSamples.hatOpen).toDestination();

    // A simple synth for melodic lines
    const synth = new Tone.Synth({
      oscillator: {
        type: "fatsawtooth",
        count: 3,
        spread: 20
      },
      envelope: {
        attack: 0.01,
        decay: 0.2,
        sustain: 0.3,
        release: 0.5
      }
    });

    // Send synth through some effects
    const filter = new Tone.AutoFilter({
      frequency: "4n",
      baseFrequency: 200,
      octaves: 2.6,
      filter: {
        type: "bandpass"
      }
    }).start();

    const reverb = new Tone.Reverb({
      decay: 2,
      wet: 0.3
    }).toDestination();

    synth.connect(filter);
    filter.connect(reverb);

    // Transport BPM
    Tone.Transport.bpm.value = 120;

    // 16 steps per measure
    const stepsPerMeasure = 16;
    let currentStep = 0;

    // Weâ€™ll store random patterns for each measure (and refresh them each measure)
    let drumPattern = {
      kick: [],
      snare: [],
      hatClosed: [],
      hatOpen: []
    };
    let synthPattern = [];

    // Pentatonic scale in A minor for some semblance of musical sense
    const scale = ["A3", "C4", "D4", "E4", "G4", "A4", "C5", "D5", "E5"];

    // -------------
    // Randomization
    // -------------
    function randomizeDrumPattern() {
      // Each array is length 16; 1 means play, 0 means no play
      drumPattern.kick = Array.from({ length: stepsPerMeasure }, () => (Math.random() < 0.4 ? 1 : 0));
      drumPattern.snare = Array.from({ length: stepsPerMeasure }, () => (Math.random() < 0.25 ? 1 : 0));
      drumPattern.hatClosed = Array.from({ length: stepsPerMeasure }, () => (Math.random() < 0.5 ? 1 : 0));
      drumPattern.hatOpen = Array.from({ length: stepsPerMeasure }, () => (Math.random() < 0.1 ? 1 : 0));
    }

    function randomizeSynthPattern() {
      // Random note from the scale for each of the 16 steps
      synthPattern = Array.from({ length: stepsPerMeasure }, () => {
        // 30% chance to play a note
        if (Math.random() < 0.3) {
          const note = scale[Math.floor(Math.random() * scale.length)];
          return note;
        } 
        return null;
      });
    }

    function randomizeEffects() {
      // Random reverb wetness & decay
      reverb.wet.value = Math.random() * 0.5;
      reverb.decay = Math.random() * 3 + 0.5; // range 0.5 - 3.5

      // Random filter base frequency & type
      const freq = Math.random() * 1000 + 200; // 200 - 1200
      filter.baseFrequency = freq;
    }

    // Initialize random patterns & effects
    randomizeDrumPattern();
    randomizeSynthPattern();
    randomizeEffects();

    // ---------------------------
    // Step Scheduler (Every 16th)
    // ---------------------------
    const loop = new Tone.Loop((time) => {
      // Play events at current step
      if (drumPattern.kick[currentStep]) kickPlayer.start(time);
      if (drumPattern.snare[currentStep]) snarePlayer.start(time);
      if (drumPattern.hatClosed[currentStep]) hatClosedPlayer.start(time);
      if (drumPattern.hatOpen[currentStep]) hatOpenPlayer.start(time);

      const note = synthPattern[currentStep];
      if (note) {
        synth.triggerAttackRelease(note, "16n", time);
      }

      currentStep = (currentStep + 1) % stepsPerMeasure;

      // If we have looped back to step 0, randomize patterns & effects again
      if (currentStep === 0) {
        randomizeDrumPattern();
        randomizeSynthPattern();
        randomizeEffects();
      }
    }, "16n").start(0);

    // -------------
    // Start/Stop UI
    // -------------
    let isPlaying = false;
    const toggleBtn = document.getElementById("toggleBtn");

    toggleBtn.addEventListener("click", async () => {
      if (!isPlaying) {
        // Start the audio context and transport
        await Tone.start();
        Tone.Transport.start();
        toggleBtn.textContent = "Stop";
      } else {
        // Stop
        Tone.Transport.stop();
        toggleBtn.textContent = "Start";
      }
      isPlaying = !isPlaying;
    });
  </script>
</body>
</html>
